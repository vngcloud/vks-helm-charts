{{- if .Values.certChecker.enabled -}}
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ .Values.certChecker.name }}
  namespace: {{ .Values.namespace }}
  labels:
    {{- include "etcd-manager.certChecker.labels" . | nindent 4 }}
  {{- with .Values.commonAnnotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  schedule: {{ .Values.certChecker.schedule | quote }}
  successfulJobsHistoryLimit: {{ .Values.certChecker.successfulJobsHistoryLimit }}
  failedJobsHistoryLimit: {{ .Values.certChecker.failedJobsHistoryLimit }}
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            {{- include "etcd-manager.certChecker.labels" . | nindent 12 }}
        spec:
          serviceAccountName: {{ include "etcd-manager.certChecker.serviceAccountName" . }}
          restartPolicy: OnFailure
          {{- with .Values.nodeSelector }}
          nodeSelector:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.affinity }}
          affinity:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.tolerations }}
          tolerations:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.podSecurityContext }}
          securityContext:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          containers:
          - name: cert-checker
            image: "{{ .Values.certChecker.image.repository }}:{{ .Values.certChecker.image.tag }}"
            imagePullPolicy: {{ .Values.certChecker.image.pullPolicy }}
            {{- with .Values.securityContext }}
            securityContext:
              {{- toYaml . | nindent 14 }}
            {{- end }}
            command:
            - /bin/bash
            - -c
            - |
              #!/bin/bash
              set -e

              # Configuration
              NAMESPACE="{{ .Values.namespace }}"
              CHECK_DAYS={{ .Values.certChecker.checkDays }}
              CONFIGMAP_NAME="{{ .Values.certChecker.configMapName }}"
              TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

              # Initialize list of instances needing renewal
              INSTANCES_NEEDING_RENEWAL=""
              TOTAL_INSTANCES=0
              INSTANCES_WITH_ISSUES=0

              # Function to check if any certificate is expiring
              check_instance_certificates() {
                local etcd_name=$1
                local needs_renewal=false

                # List of certificates to check
                local certificates=(
                  "${etcd_name}-certs:ca.crt"
                  "${etcd_name}-certs:peer.pem"
                  "${etcd_name}-certs:server.pem"
                  "${etcd_name}-root-client-certs:tls.crt"
                )

                for cert_info in "${certificates[@]}"; do
                  IFS=':' read -r secret_name certificate <<< "$cert_info"

                  # Check if secret exists
                  if ! kubectl get secret "$secret_name" -n "$NAMESPACE" &>/dev/null; then
                    echo "WARNING: Secret $secret_name not found for ${etcd_name}" >&2
                    continue
                  fi

                  # Get certificate expiration
                  local expiration_raw
                  expiration_raw=$(kubectl get secret "$secret_name" -n "$NAMESPACE" -o json | \
                    jq -r ".data[\"$certificate\"]" | \
                    base64 --decode | \
                    openssl x509 -noout -enddate 2>/dev/null) || {
                      echo "ERROR: Failed to read certificate $certificate from $secret_name" >&2
                      continue
                    }

                  local expiration_date=$(echo "$expiration_raw" | cut -d= -f2)
                  local expiration_epoch=$(date -d "$expiration_date" +%s)
                  local now_epoch=$(date +%s)
                  local remaining_days=$(( (expiration_epoch - now_epoch) / 86400 ))

                  if [ "$remaining_days" -le "$CHECK_DAYS" ]; then
                    echo "Found expiring certificate in ${etcd_name}: ${certificate} expires in ${remaining_days} days" >&2
                    needs_renewal=true
                  fi
                done

                # Return status (only this goes to stdout)
                if [ "$needs_renewal" = true ]; then
                  echo "true"
                else
                  echo "false"
                fi
              }

              # Function to check if health checks are configured
              check_health_checks() {
                local etcd_name=$1
                local needs_config=false

                # Check if Service has publishNotReadyAddresses
                local has_publish=$(kubectl get svc "$etcd_name" -n "$NAMESPACE" -o jsonpath='{.spec.publishNotReadyAddresses}' 2>/dev/null || echo "")

                if [[ "$has_publish" != "true" ]]; then
                  echo "Service ${etcd_name} missing publishNotReadyAddresses=true" >&2
                  needs_config=true
                fi

                # Check if StatefulSet has health probes
                local has_liveness=$(kubectl get statefulset "$etcd_name" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].livenessProbe}' 2>/dev/null || echo "")
                local has_readiness=$(kubectl get statefulset "$etcd_name" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].readinessProbe}' 2>/dev/null || echo "")

                if [[ -z "$has_liveness" || -z "$has_readiness" ]]; then
                  echo "StatefulSet ${etcd_name} missing health probes (liveness or readiness)" >&2
                  needs_config=true
                fi

                # Return status (only this goes to stdout)
                if [ "$needs_config" = true ]; then
                  echo "true"
                else
                  echo "false"
                fi
              }

              # Main execution
              echo "Starting certificate and health check for namespace: ${NAMESPACE}"

              # Get all ETCD statefulsets
              etcd_statefulsets=$(kubectl get statefulsets -n "$NAMESPACE" -o json | \
                jq -r '.items[] | select(.metadata.name | contains("ds-") or contains("datastore")) | .metadata.name')

              if [ -z "$etcd_statefulsets" ]; then
                echo "No ETCD statefulsets found in namespace ${NAMESPACE}"
              else
                # Check each ETCD instance for certificates AND health checks
                for etcd_name in $etcd_statefulsets; do
                  echo "Checking: ${etcd_name}"
                  TOTAL_INSTANCES=$((TOTAL_INSTANCES + 1))

                  needs_action=false

                  # Check certificates
                  cert_check=$(check_instance_certificates "$etcd_name")
                  if [ "$cert_check" = "true" ]; then
                    echo "  → Certificate check: NEEDS RENEWAL" >&2
                    needs_action=true
                  else
                    echo "  → Certificate check: OK" >&2
                  fi

                  # Check health configuration (OR condition)
                  health_check=$(check_health_checks "$etcd_name")
                  if [ "$health_check" = "true" ]; then
                    echo "  → Health check config: NEEDS CONFIGURATION" >&2
                    needs_action=true
                  else
                    echo "  → Health check config: OK" >&2
                  fi

                  # Add to list if either condition is true (OR logic)
                  if [ "$needs_action" = true ]; then
                    INSTANCES_WITH_ISSUES=$((INSTANCES_WITH_ISSUES + 1))
                    if [ -n "$INSTANCES_NEEDING_RENEWAL" ]; then
                      INSTANCES_NEEDING_RENEWAL="${INSTANCES_NEEDING_RENEWAL},"
                    fi
                    INSTANCES_NEEDING_RENEWAL="${INSTANCES_NEEDING_RENEWAL}${etcd_name}"
                    echo "Added ${etcd_name} to action list"
                  else
                    echo "${etcd_name} is fully configured and certificates are valid"
                  fi
                done
              fi

              # Save to ConfigMap
              echo "Saving results to ConfigMap: ${CONFIGMAP_NAME}"

              # Create or update the ConfigMap with just the instance names
              kubectl create configmap "${CONFIGMAP_NAME}" \
                --from-literal=instances="${INSTANCES_NEEDING_RENEWAL}" \
                --from-literal=last-check="${TIMESTAMP}" \
                --from-literal=total-instances="${TOTAL_INSTANCES}" \
                --from-literal=instances-with-issues="${INSTANCES_WITH_ISSUES}" \
                --from-literal=namespace="${NAMESPACE}" \
                --dry-run=client -o yaml | kubectl apply -f -

              echo "Certificate and health check completed"
              echo "Total instances checked: ${TOTAL_INSTANCES}"
              echo "Instances needing action: ${INSTANCES_WITH_ISSUES}"
              if [ -n "$INSTANCES_NEEDING_RENEWAL" ]; then
                echo "List: ${INSTANCES_NEEDING_RENEWAL}"
              else
                echo "No instances need action"
              fi
            resources:
              {{- toYaml .Values.certChecker.resources | nindent 14 }}
{{- end }}